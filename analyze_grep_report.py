#!/usr/bin/env python3
import re
import os

# This is the path to the report file generated by grep.
# I will use an absolute path to ensure it's found.
# The script assumes it will be run from a context where this path is valid.
REPORT_FILE_PATH = "/mnt/c/Users/Osamu/AndroidStudioProjects/OSRSWiki/problematic_comments_report.txt"

def analyze_report_line(report_line_text):
    """
    Analyzes a single line from the grep report.
    """
    # original_line is the raw line from the grep output file
    original_line = report_line_text.strip()
    
    # Parts are: filepath, linenumber, matched_code_segment
    parts = original_line.split(':', 2)
    if len(parts) < 3:
        return {
            "original_line": original_line, 
            "filepath": "", 
            "linenumber": "", 
            "code_segment": "", 
            "is_comment": False, 
            "problem_type": "parse_error", 
            "confidence": "low",
            "suggestion": "Malformed line in report file."
        }

    filepath, linenum_str, code_segment = parts
    # The actual content of the line from the source file, as captured by grep
    # We strip leading/trailing whitespace from this segment for analysis
    line_content_for_analysis = code_segment.strip()

    analysis_result = {
        "original_line": original_line,
        "filepath": filepath,
        "linenumber": linenum_str,
        "code_segment": code_segment, # Keep original segment from grep for display
        "is_comment": False,
        "problem_type": None,  # "second_person", "user_interaction"
        "confidence": "low",   # "low", "medium", "high"
        "suggestion": "Manual review recommended."
    }

    # Heuristics to determine if the line is likely a comment
    is_likely_comment = False
    file_ext = os.path.splitext(filepath)[1].lower()

    if file_ext in ['.kt', '.java', '.gradle', '.gradle.kts']:
        if line_content_for_analysis.startswith('//'):
            is_likely_comment = True
        # Check for lines within /* ... */ block comments.
        # A line starting with '*' (but not '*/') inside a block is common.
        elif line_content_for_analysis.startswith('*') and not line_content_for_analysis.startswith('*/'):
            is_likely_comment = True
        # Grep might have caught the line starting /* or a single-line /* ... */
        elif '/*' in line_content_for_analysis: # Simplified: if /* is anywhere, assume comment context for this line
            is_likely_comment = True
    elif file_ext == '.xml':
        # For XML, check if the line content looks like an XML comment.
        if line_content_for_analysis.startswith(''):
            is_likely_comment = True
        elif line_content_for_analysis.startswith(''): # End of a multi-line XML comment
             is_likely_comment = True # Though the problematic text might not be on this closing line

    analysis_result["is_comment"] = is_likely_comment

    if is_likely_comment:
        # Check for second-person pronouns
        if re.search(r'\b(you|your|yourself)\b', code_segment, re.IGNORECASE):
            analysis_result["problem_type"] = "second_person"
            analysis_result["confidence"] = "medium"
            analysis_result["suggestion"] = "Review for second-person pronoun addressing the developer."

        # Check for user interaction phrases (these are more specific)
        if re.search(r'user confirmed|user mentioned', code_segment, re.IGNORECASE):
            # If both types found, user_interaction is usually more specific
            analysis_result["problem_type"] = "user_interaction" 
            analysis_result["confidence"] = "high"
            analysis_result["suggestion"] = "Review for phrases referring to prior user interaction."

        # Refine confidence for second_person if common problematic patterns are found
        if analysis_result["problem_type"] == "second_person":
            if re.search(r'\b(you should|you must|you need to|ensure you|make sure you|if you want|allows you to)\b', code_segment, re.IGNORECASE):
                analysis_result["confidence"] = "high"
            elif re.search(r'\b(your task|your code|your responsibility|for your convenience)\b', code_segment, re.IGNORECASE):
                analysis_result["confidence"] = "high"
    
    # If not identified as a comment by heuristics, but keywords are present, flag for review
    if not is_likely_comment and (re.search(r'\b(you|your|yourself|user confirmed|user mentioned)\b', code_segment, re.IGNORECASE)):
        analysis_result["suggestion"] = "Keyword found, but not clearly identified as a comment by script. Verify context."
        analysis_result["problem_type"] = "keyword_in_non_comment_or_unclear_comment"
        analysis_result["confidence"] = "low"


    return analysis_result

def main():
    # My code comments are written from my perspective, for my codebase.
    # This script processes a report file to help identify comments
    # that may not align with that principle.
    
    print(f"Analyzing report file: {REPORT_FILE_PATH}")
    analyzed_results = []
    
    if not os.path.exists(REPORT_FILE_PATH):
        print(f"Error: Report file not found at '{REPORT_FILE_PATH}'")
        print("Please ensure the path is correct and the grep report was generated.")
        return

    try:
        with open(REPORT_FILE_PATH, 'r', encoding='utf-8') as f:
            for line_number, line_text in enumerate(f, 1):
                if line_text.strip(): # Ensure not an empty line
                    result = analyze_report_line(line_text)
                    result['report_file_line_number'] = line_number # Add line number from report file itself
                    analyzed_results.append(result)
    except Exception as e:
        print(f"Error reading or processing report file: {e}")
        return

    potential_issues_identified = 0
    if not analyzed_results:
        print("No lines found in the report file to analyze.")
        return

    print("\n--- Script Analysis Results ---")
    for result in analyzed_results:
        # I only want to print details for lines that are possibly problematic comments
        # or lines where keywords were found but comment status was unclear.
        if result.get("problem_type") and result["problem_type"] != "parse_error":
            if result["is_comment"] or result["problem_type"] == "keyword_in_non_comment_or_unclear_comment":
                potential_issues_identified +=1
                print(f"------------------------------")
                print(f"Match from report file line: {result.get('report_file_line_number')}")
                print(f"  File Path: {result['filepath']}")
                print(f"  Source Line No: {result['linenumber']}")
                print(f"  Original Code Segment (from grep): {result['code_segment'].strip()}")
                if result['is_comment']:
                    print(f"  Script Assessment: Likely a comment.")
                else:
                    print(f"  Script Assessment: Context unclear or not identified as a comment by script.")
                print(f"  Identified Problem Type: {result['problem_type']}")
                print(f"  Confidence (by script): {result['confidence']}")
                print(f"  Script Suggestion: {result['suggestion']}")
    
    print(f"==============================")
    print(f"Total lines processed from report file: {len(analyzed_results)}")
    print(f"Script highlighted {potential_issues_identified} lines for closer review.")
    print("Please manually verify these findings by checking the original source files.")

if __name__ == '__main__':
    main()
