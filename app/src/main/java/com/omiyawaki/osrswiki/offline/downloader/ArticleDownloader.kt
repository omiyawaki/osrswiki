package com.omiyawaki.osrswiki.offline.downloader

import android.util.Log
import com.omiyawaki.osrswiki.network.interceptor.OsrsOfflineAssetInterceptor
import com.omiyawaki.osrswiki.offline.db.SavedArticleEntry
import com.omiyawaki.osrswiki.offline.db.SavedArticleEntryDao
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import org.json.JSONObject
import java.io.IOException

// Define status values, ideally this would be an enum in SavedArticleEntry.kt
object ArticleSaveStatus {
    const val PENDING = "PENDING"
    const val DOWNLOADING_HTML = "DOWNLOADING_HTML"
    const val DOWNLOADING_IMAGES = "DOWNLOADING_IMAGES"
    const val COMPLETE = "COMPLETE"
    const val FAILED = "FAILED"
}

class ArticleDownloader(
    private val okHttpClient: OkHttpClient, // Must be configured with OsrsOfflineAssetInterceptor
    private val savedArticleEntryDao: SavedArticleEntryDao,
    private val mediaWikiApiBaseUrl: String = "https://oldschool.runescape.wiki/api.php"
) {
    companion object {
        private const val TAG = "ArticleDownloader"
    }

    /**
     * Downloads an article and its images for offline use.
     * Assumes SavedArticleEntry has a 'status: String' field.
     *
     * @param articlePageTitle The MediaWiki title of the page (e.g., "Abyssal_whip").
     * @param articleHtmlUrl The direct URL to the article's HTML content (if known, otherwise could be derived).
     * @param displayTitle The title to be displayed for the article.
     * @param normalizedTitle The normalized title for searching.
     * @param snippet An optional snippet.
     * @return True if the core HTML download was successful, false otherwise.
     * Image download failures are logged but don't cause this method to return false.
     */
    suspend fun downloadAndSaveArticle(
        articlePageTitle: String,
        articleHtmlUrl: String,
        displayTitle: String,
        normalizedTitle: String,
        snippet: String?
    ): Boolean = withContext(Dispatchers.IO) {
        Log.i(TAG, "Starting download for article: $displayTitle (URL: $articleHtmlUrl)")

        var entry = SavedArticleEntry(
            articleTitle = displayTitle,
            normalizedArticleTitle = normalizedTitle,
            snippet = snippet,
            timestamp = System.currentTimeMillis(),
            // Assuming a 'status' field exists in SavedArticleEntry.kt
            // status = ArticleSaveStatus.PENDING // Set initial status
        )
        // Placeholder for status; actual update needs the entity to have the field
        // For now, we'll manage status conceptually and update the entry at the end.
        // entry.id will be 0 until inserted.

        var currentStatus = ArticleSaveStatus.PENDING
        var entryId: Long = 0

        try {
            // Insert initial entry to get an ID
            currentStatus = ArticleSaveStatus.DOWNLOADING_HTML
            // Update 'entry' with the ID after insertion if we were to update status iteratively
            // For now, let's create it once at the end or if HTML download is successful.

            Log.d(TAG, "Requesting HTML download for $articleHtmlUrl, to be handled by interceptor.")
            val htmlRequest = Request.Builder()
                .url(articleHtmlUrl)
                .header(OsrsOfflineAssetInterceptor.HEADER_SAVE_ASSET, "true")
                // We need an ID for the interceptor. Let's insert a preliminary entry first.
                // This is a bit of a chicken-and-egg if the ID is autogenerated.
                // Option 1: Interceptor handles OfflineAsset without SavedArticleEntry.id initially,
                //           and a later process links them. (More complex)
                // Option 2: Generate a UUID for the transaction, pass it, and link later.
                // Option 3: Save HTML, then create entry, then save images.
                // Let's go with creating the entry after HTML is confirmed saved by the interceptor.
                // The interceptor will need to work with OfflineAssetDao without an immediate link
                // or the link is established after the fact by the orchestrator.

                // Revised plan: Interceptor needs SavedArticleEntry.id.
                // So, insert SavedArticleEntry first.
                val preliminaryEntry = SavedArticleEntry(
                    articleTitle = displayTitle,
                    normalizedArticleTitle = normalizedTitle,
                    snippet = snippet,
                    timestamp = System.currentTimeMillis()
                    // status = ArticleSaveStatus.DOWNLOADING_HTML // Add this field to the entity
                )
                entryId = savedArticleEntryDao.insert(preliminaryEntry) // Assuming insert returns the ID
                if (entryId == 0L) { // Or -1L depending on DAO
                     Log.e(TAG, "Failed to insert preliminary SavedArticleEntry for $displayTitle")
                     // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.FAILED) // If status field exists
                     return@withContext false
                }
                // Log.d(TAG, "Preliminary entry inserted with ID: $entryId, status: ${ArticleSaveStatus.DOWNLOADING_HTML}")
                // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.DOWNLOADING_HTML)


                .header(OsrsOfflineAssetInterceptor.HEADER_SAVED_ARTICLE_ENTRY_ID, entryId.toString())
                .header(OsrsOfflineAssetInterceptor.HEADER_ASSET_ORIGINAL_URL, articleHtmlUrl)
                .header(OsrsOfflineAssetInterceptor.HEADER_ASSET_TYPE, "html")
                .build()

            val htmlResponse = okHttpClient.newCall(htmlRequest).execute()

            if (!htmlResponse.isSuccessful) {
                Log.e(TAG, "HTML download failed for $articleHtmlUrl. Code: ${htmlResponse.code}")
                // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.FAILED)
                htmlResponse.close()
                return@withContext false
            }
            htmlResponse.close() // Close response body, interceptor handled saving.
            Log.i(TAG, "HTML for $displayTitle processed by interceptor.")
            // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.DOWNLOADING_IMAGES)
            currentStatus = ArticleSaveStatus.DOWNLOADING_IMAGES


            // Step 2: Get image filenames from the page
            Log.d(TAG, "Fetching image filenames for page title: $articlePageTitle")
            val imageFileTitles = getImageFileTitles(articlePageTitle)
            if (imageFileTitles.isEmpty()) {
                Log.i(TAG, "No image file titles found for $articlePageTitle.")
            } else {
                Log.d(TAG, "Found ${imageFileTitles.size} image file titles. Fetching their URLs...")
                // Step 3: Get image URLs from filenames
                val imageUrls = getImageUrls(imageFileTitles)
                Log.d(TAG, "Found ${imageUrls.size} image URLs to download.")

                for (imageUrl in imageUrls) {
                    Log.d(TAG, "Requesting image download for $imageUrl, to be handled by interceptor.")
                    val imageRequest = Request.Builder()
                        .url(imageUrl)
                        .header(OsrsOfflineAssetInterceptor.HEADER_SAVE_ASSET, "true")
                        .header(OsrsOfflineAssetInterceptor.HEADER_SAVED_ARTICLE_ENTRY_ID, entryId.toString())
                        .header(OsrsOfflineAssetInterceptor.HEADER_ASSET_ORIGINAL_URL, imageUrl)
                        .header(OsrsOfflineAssetInterceptor.HEADER_ASSET_TYPE, "image")
                        .build()
                    try {
                        val imageResponse = okHttpClient.newCall(imageRequest).execute()
                        if (!imageResponse.isSuccessful) {
                            Log.w(TAG, "Failed to download image $imageUrl. Code: ${imageResponse.code}")
                        }
                        imageResponse.close() // Close response, interceptor handled content
                    } catch (e: IOException) {
                        Log.w(TAG, "IOException during image download for $imageUrl", e)
                        // Continue to next image
                    }
                }
            }

            Log.i(TAG, "Article download process complete for $displayTitle.")
            // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.COMPLETE)
            currentStatus = ArticleSaveStatus.COMPLETE
            return@withContext true

        } catch (e: Exception) {
            Log.e(TAG, "Error during article download for $displayTitle", e)
            if (entryId != 0L) {
                // savedArticleEntryDao.updateStatus(entryId, ArticleSaveStatus.FAILED)
            }
            currentStatus = ArticleSaveStatus.FAILED
            return@withContext false
        } finally {
            // If SavedArticleEntry has a status field, ensure it's updated with the final status
            // For now, this 'finally' block is a placeholder for that logic.
            // Example: if (entryId != 0L) savedArticleEntryDao.updateStatus(entryId, currentStatus)
            Log.d(TAG, "Final status for $displayTitle (ID: $entryId): $currentStatus")
        }
    }

    @Throws(IOException::class)
    private fun getImageFileTitles(pageTitle: String): List<String> {
        val urlBuilder = mediaWikiApiBaseUrl.toHttpUrlOrNull()?.newBuilder()
            ?: throw IllegalArgumentException("Invalid MediaWiki API base URL")
        urlBuilder.addQueryParameter("action", "query")
        urlBuilder.addQueryParameter("titles", pageTitle)
        urlBuilder.addQueryParameter("prop", "images")
        urlBuilder.addQueryParameter("imlimit", "max") // Get all images
        urlBuilder.addQueryParameter("format", "json")

        val request = Request.Builder().url(urlBuilder.build()).build()
        val response = okHttpClient.newCall(request).execute()

        if (!response.isSuccessful) throw IOException("API request for image titles failed with code ${response.code}")

        val responseBody = response.body?.string() ?: throw IOException("Empty response body for image titles")
        response.close()

        val fileTitles = mutableListOf<String>()
        val jsonResponse = JSONObject(responseBody)
        val pages = jsonResponse.optJSONObject("query")?.optJSONObject("pages")
        pages?.keys()?.forEach { pageId ->
            val page = pages.optJSONObject(pageId)
            page?.optJSONArray("images")?.let { imagesArray ->
                for (i in 0 until imagesArray.length()) {
                    imagesArray.optJSONObject(i)?.optString("title")?.let { title ->
                        if (title.isNotBlank()) fileTitles.add(title)
                    }
                }
            }
        }
        return fileTitles
    }

    @Throws(IOException::class)
    private fun getImageUrls(fileTitles: List<String>): List<String> {
        if (fileTitles.isEmpty()) return emptyList()

        // MediaWiki API often has a limit on the number of titles per request (e.g., 50)
        val imageUrls = mutableListOf<String>()
        val titleChunks = fileTitles.chunked(50) // Process in chunks of 50

        for (chunk in titleChunks) {
            val urlBuilder = mediaWikiApiBaseUrl.toHttpUrlOrNull()?.newBuilder()
                ?: throw IllegalArgumentException("Invalid MediaWiki API base URL")
            urlBuilder.addQueryParameter("action", "query")
            urlBuilder.addQueryParameter("titles", chunk.joinToString("|"))
            urlBuilder.addQueryParameter("prop", "imageinfo")
            urlBuilder.addQueryParameter("iiprop", "url")
            urlBuilder.addQueryParameter("format", "json")

            val request = Request.Builder().url(urlBuilder.build()).build()
            val response = okHttpClient.newCall(request).execute()

            if (!response.isSuccessful) {
                Log.w(TAG, "API request for image URLs failed for chunk with code ${response.code}")
                continue // Try next chunk
            }
            val responseBody = response.body?.string() ?: continue
            response.close()

            try {
                val jsonResponse = JSONObject(responseBody)
                val pages = jsonResponse.optJSONObject("query")?.optJSONObject("pages")
                pages?.keys()?.forEach { pageId ->
                    pages.optJSONObject(pageId)?.optJSONArray("imageinfo")?.let { imageInfoArray ->
                        if (imageInfoArray.length() > 0) {
                            imageInfoArray.optJSONObject(0)?.optString("url")?.let { url ->
                                if (url.isNotBlank()) imageUrls.add(url)
                            }
                        }
                    }
                }
            } catch (e: org.json.JSONException) {
                Log.e(TAG, "Failed to parse JSON for image URLs: $responseBody", e)
            }
        }
        return imageUrls
    }
}
