package com.omiyawaki.osrswiki.ui.article

import android.os.Bundle
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import com.omiyawaki.osrswiki.OSRSWikiApplication
import com.omiyawaki.osrswiki.R
import com.omiyawaki.osrswiki.data.repository.ArticleRepository
import com.omiyawaki.osrswiki.databinding.FragmentPageBinding
import com.omiyawaki.osrswiki.page.PageViewModel
import com.omiyawaki.osrswiki.util.log.L
import dagger.hilt.android.EntryPointAccessors

class PageFragment : Fragment() {

    private var _binding: FragmentPageBinding? = null
    private val binding get() = _binding!!

    private val pageViewModel = PageViewModel()
    private lateinit var articleRepository: ArticleRepository
    private lateinit var articleContentLoader: ArticleContentLoader

    private var articleTitleArg: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        L.d("PageFragment onCreate")

        arguments?.let {
            articleTitleArg = it.getString(ARG_ARTICLE_TITLE)
        }

        val repositoryEntryPoint = EntryPointAccessors.fromApplication(
            requireActivity().applicationContext,
            OSRSWikiApplication.RepositoryEntryPoint::class.java
        )
        articleRepository = repositoryEntryPoint.articleRepository()

        articleContentLoader = ArticleContentLoader(
            articleRepository,
            pageViewModel,
            lifecycleScope,
            onStateUpdated = {
                // Ensure UI updates happen on the main thread, though lifecycleScope typically handles this.
                // For explicit safety if ever changing dispatcher in loader:
                // activity?.runOnUiThread { updateUiFromViewModel() }
                updateUiFromViewModel()
            }
        )
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        L.d("PageFragment onCreateView")
        _binding = FragmentPageBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        L.d("PageFragment onViewCreated. Article title from arg: $articleTitleArg")

        // Set initial UI state (likely loading as per ArticleUiState default)
        updateUiFromViewModel()

        articleTitleArg?.let { title ->
            // Load only if the title is different from current VM's title or content is missing,
            // or if it's the initial load for this fragment instance with this title.
            // The loader now calls onStateUpdated to set the initial loading state too.
            if (pageViewModel.uiState.title != title || pageViewModel.uiState.htmlContent == null && !pageViewModel.uiState.isLoading && pageViewModel.uiState.error == null) {
                 L.i("Requesting to load article: $title")
                articleContentLoader.loadArticleByTitle(title)
            } else if (pageViewModel.uiState.title == title && (pageViewModel.uiState.isLoading || pageViewModel.uiState.error != null)) {
                // If it's the same title but currently loading or in error, UI will reflect from updateUiFromViewModel.
                // No new load needed unless a retry is intended.
                L.d("Article '$title' is already loading or in error state. UI will reflect.")
            } else {
                L.d("Article '$title' data already present in ViewModel. UI will reflect.")
            }
        } ?: L.w("No article title provided to PageFragment.")

        binding.errorTextView.setOnClickListener {
            articleTitleArg?.let { title ->
                L.i("Retry button clicked for article: $title")
                // The loader will set loading state and call onStateUpdated.
                articleContentLoader.loadArticleByTitle(title, forceNetwork = true)
            }
        }
    }

    private fun updateUiFromViewModel() {
        L.d("PageFragment updateUiFromViewModel. Current state: ${pageViewModel.uiState}")
        val state = pageViewModel.uiState

        if (state.isLoading) {
            binding.progressBar.visibility = View.VISIBLE
            binding.articleContentTextView.visibility = View.GONE
            binding.errorTextView.visibility = View.GONE
            binding.articleTitleTextView.text = state.title ?: getString(R.string.label_loading)
        } else {
            binding.progressBar.visibility = View.GONE
        }

        state.error?.let {
            binding.errorTextView.text = it
            binding.errorTextView.visibility = View.VISIBLE
            binding.articleContentTextView.visibility = View.GONE
            // Keep the title that was attempted, or show a generic error title
            binding.articleTitleTextView.text = state.title ?: getString(R.string.label_error_loading_article)
        } ?: run {
            if (!state.isLoading) binding.errorTextView.visibility = View.GONE
        }

        if (!state.isLoading && state.error == null) {
            binding.articleContentTextView.visibility = View.VISIBLE
            binding.articleTitleTextView.text = state.title ?: getString(R.string.label_title_unavailable)
            binding.articleContentTextView.text = state.htmlContent?.let {
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
                    Html.fromHtml(it, Html.FROM_HTML_MODE_LEGACY)
                } else {
                    @Suppress("DEPRECATION")
                    Html.fromHtml(it)
                }
            } ?: getString(R.string.label_content_unavailable)
        } else if (!state.isLoading && state.error != null) {
            // Content should be hidden if there was an error
            binding.articleContentTextView.visibility = View.GONE
        }
        L.i("PageFragment UI updated for title: '${state.title}', isLoading: ${state.isLoading}, error: ${state.error != null}")
    }

    override fun onDestroyView() {
        super.onDestroyView()
        L.d("PageFragment onDestroyView")
        _binding = null
    }

    companion object {
        private const val ARG_ARTICLE_TITLE = "article_title"

        @JvmStatic
        fun newInstance(articleTitle: String): PageFragment {
            L.d("PageFragment newInstance for title: $articleTitle")
            return PageFragment().apply {
                arguments = Bundle().apply {
                    putString(ARG_ARTICLE_TITLE, articleTitle)
                }
            }
        }
    }
}
